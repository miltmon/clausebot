from fastapi import FastAPI, Header, HTTPException, Request, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import time, hashlib, os
from typing import List, Dict, Any, Optional
import json
from datetime import datetime

# Import security and observability modules
try:
    from .security import (
        APIKeyAuth,
        get_api_key_info,
        check_scope,
        generate_request_id,
        log_security_event,
        security_middleware,
    )
except ImportError:
    from ..security import (  # fallback if security.py is one level up
        APIKeyAuth,
        get_api_key_info,
        check_scope,
        generate_request_id,
        log_security_event,
        security_middleware,
    )
from .observability import (
    MetricsCollector,
    record_request_metrics,
    get_metrics_summary,
    check_system_health,
    check_readiness,
    logger,
)
from .content_integrity import (
    get_edition_guard,
    generate_clause_checksum,
    content_manager,
)

app = FastAPI(title="ClauseBot Local API", version="1.0.0")
EDITION = os.getenv("CLAUSEBOT_EDITION", "AWS_D1.1:2020")
CONTENT_DIR = os.getenv("CONTENT_DIR", "./data")
INDEX_DIR = os.getenv("INDEX_DIR", "./data/codes/aws_d1_1_2020/index")
CACHE_TTL_SECONDS = int(os.getenv("CACHE_TTL_SECONDS", "86400"))

# Simple in-memory cache with TTL
cache = {}
cache_timestamps = {}

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://www.miltmonndt.com",
        "https://miltmon-80193.bubbleapps.io",
        "capacitor://localhost",
        "http://localhost:3000",
        "http://localhost:5173",
    ],
    allow_credentials=True,
    allow_methods=["GET", "POST"],
    allow_headers=["*"],
)

# Add security middleware
app.middleware("http")(security_middleware)

# API Key authentication
api_key_auth = APIKeyAuth()


class ExplainReq(BaseModel):
    audience: str = "student"
    depth: str = "standard"
    locale: str = "en-US"


class ScriptReq(BaseModel):
    duration_min: int = 2
    tone: str = "plain"
    format: str = "voiceover"
    audience: str = "student"


class LogReq(BaseModel):
    artifact_id: str
    clause: str
    edition: str
    step: str
    actor: str
    status: str


class ErrorResponse(BaseModel):
    code: str
    message: str
    details: Optional[Dict[str, Any]] = None
    request_id: str


def get_cache_key(code: str, clause: str, operation: str) -> str:
    return f"{code}:{clause}:{operation}"


def is_cache_valid(cache_key: str) -> bool:
    """Check if cache entry is still valid"""
    if cache_key not in cache_timestamps:
        return False

    cache_time = cache_timestamps[cache_key]
    return (time.time() - cache_time) < CACHE_TTL_SECONDS


def set_cache_entry(cache_key: str, value: Any):
    """Set cache entry with timestamp"""
    cache[cache_key] = value
    cache_timestamps[cache_key] = time.time()


def get_cache_entry(cache_key: str) -> Optional[Any]:
    """Get cache entry if valid"""
    if cache_key in cache and is_cache_valid(cache_key):
        return cache[cache_key]
    return None


@app.get("/health")
def health():
    """Health check endpoint - lightweight, no auth required"""
    return check_system_health()


@app.get("/ready")
def ready():
    """Readiness check endpoint - checks if system is ready to serve requests"""
    return check_readiness()


@app.get("/metrics")
def metrics():
    """Metrics endpoint for monitoring"""
    return get_metrics_summary()


@app.get("/v1/edition")
def get_edition_info():
    """Get current edition information"""
    return content_manager.get_edition_info()


@app.get("/v1/integrity/check")
def check_integrity():
    """Check content integrity"""
    return content_manager.verify_checksums()


@app.post("/v1/clauses/{code}/{clause}/explain")
def explain(
    code: str,
    clause: str,
    body: ExplainReq,
    request: Request,
    authorization: str = Header(None),
):
    t0 = time.time()
    request_id = getattr(request.state, "request_id", "unknown")

    try:
        # Check scope
        api_key = getattr(request.state, "api_key", None)
        if api_key and not check_scope(api_key, "read:clause"):
            raise HTTPException(
                status_code=403, detail="Insufficient scope: read:clause required"
            )

        # Check cache first
        cache_key = get_cache_key(code, clause, "explain")
        cached_result = get_cache_entry(cache_key)
        if cached_result:
            cached_result["telemetry"]["cache_hit"] = True
            cached_result["telemetry"]["latency_ms"] = int((time.time() - t0) * 1000)
            record_request_metrics(
                "/v1/clauses/{code}/{clause}/explain",
                200,
                time.time() - t0,
                cache_hit=True,
            )
            logger.log(
                "INFO",
                f"Cache hit for clause {code}:{clause}",
                request_id,
                cache_hit=True,
            )
            return cached_result

        # Validate edition
        edition = get_edition_guard()

        # Bible Stop Gate: enforce authority terms
        if code.upper().startswith("AWS"):
            label = "Clause"
        elif code.upper().startswith("ASME"):
            label = "Chapter"
        else:
            label = "Section"

        # Generate response
        ref_checksum = generate_clause_checksum(code, clause, edition)
        payload = {
            "summary": f"Plain-English core requirement for {label} {clause} in {code} {edition}. This section defines the essential criteria and acceptance standards for welding procedures and performance qualifications.",
            "examples": [
                {
                    "title": "Shop scenario",
                    "text": f"In a fabrication shop, {label} {clause} would apply when establishing welding procedures for structural steel components. The inspector must verify that all welding parameters meet the specified requirements.",
                },
                {
                    "title": "Field scenario",
                    "text": f"During field construction, {label} {clause} governs the acceptance criteria for welds in critical load-bearing applications. Any deviation requires documented justification and approval.",
                },
            ],
            "pitfalls": [
                "Common misread: Confusing acceptance criteria with rejection criteria",
                "Common misread: Not considering material thickness variations in application",
            ],
            "refs": {
                "code": code,
                "edition": edition,
                "clause": clause,
                "tables": ["Table 8.1", "Table 6.1"],
                "figures": ["Figure 6.1", "Figure 8.1"],
            },
            "ref_checksum": ref_checksum,
            "telemetry": {
                "model": "local-gen",
                "latency_ms": int((time.time() - t0) * 1000),
                "cache_hit": False,
            },
        }

        # Cache the result
        set_cache_entry(cache_key, payload.copy())

        # Record metrics
        record_request_metrics(
            "/v1/clauses/{code}/{clause}/explain",
            200,
            time.time() - t0,
            cache_hit=False,
        )
        logger.log(
            "INFO",
            f"Generated explanation for clause {code}:{clause}",
            request_id,
            clause=clause,
            edition=edition,
            latency_ms=int((time.time() - t0) * 1000),
        )

        return payload

    except HTTPException:
        raise
    except Exception as e:
        record_request_metrics(
            "/v1/clauses/{code}/{clause}/explain", 500, time.time() - t0
        )
        logger.log(
            "ERROR",
            f"Error generating explanation for clause {code}:{clause}",
            request_id,
            error=str(e),
        )
        raise HTTPException(status_code=500, detail="Internal server error")


@app.post("/v1/clauses/{code}/{clause}/script")
def script(
    code: str,
    clause: str,
    body: ScriptReq,
    request: Request,
    authorization: str = Header(None),
):
    t0 = time.time()
    request_id = getattr(request.state, "request_id", "unknown")

    try:
        # Check scope
        api_key = getattr(request.state, "api_key", None)
        if api_key and not check_scope(api_key, "gen:script"):
            raise HTTPException(
                status_code=403, detail="Insufficient scope: gen:script required"
            )

        # Check cache first
        cache_key = get_cache_key(code, clause, "script")
        cached_result = get_cache_entry(cache_key)
        if cached_result:
            cached_result["telemetry"]["cache_hit"] = True
            cached_result["telemetry"]["latency_ms"] = int((time.time() - t0) * 1000)
            record_request_metrics(
                "/v1/clauses/{code}/{clause}/script",
                200,
                time.time() - t0,
                cache_hit=True,
            )
            return cached_result

        # Validate edition
        edition = get_edition_guard()

        # Generate script
        ref_checksum = generate_clause_checksum(code, clause, edition)
        payload = {
            "script": f"Welcome to {code} {clause}. This {body.duration_min}-minute explanation covers the essential requirements for welding inspection. [Script content would be generated based on clause content]",
            "duration_min": body.duration_min,
            "format": body.format,
            "tone": body.tone,
            "audience": body.audience,
            "refs": {
                "code": code,
                "edition": edition,
                "clause": clause,
                "tables": ["Table 8.1"],
                "figures": [],
            },
            "ref_checksum": ref_checksum,
            "telemetry": {
                "model": "local-gen",
                "latency_ms": int((time.time() - t0) * 1000),
                "cache_hit": False,
            },
        }

        # Cache the result
        set_cache_entry(cache_key, payload.copy())

        # Record metrics
        record_request_metrics(
            "/v1/clauses/{code}/{clause}/script", 200, time.time() - t0, cache_hit=False
        )
        logger.log(
            "INFO",
            f"Generated script for clause {code}:{clause}",
            request_id,
            clause=clause,
            edition=edition,
            duration_min=body.duration_min,
        )

        return payload

    except HTTPException:
        raise
    except Exception as e:
        record_request_metrics(
            "/v1/clauses/{code}/{clause}/script", 500, time.time() - t0
        )
        logger.log(
            "ERROR",
            f"Error generating script for clause {code}:{clause}",
            request_id,
            error=str(e),
        )
        raise HTTPException(status_code=500, detail="Internal server error")


@app.get("/v1/clauses/{code}/{clause}/summary")
def summary(
    code: str, clause: str, request: Request, authorization: str = Header(None)
):
    """Quick summary endpoint for mobile UI paint"""
    t0 = time.time()
    request_id = getattr(request.state, "request_id", "unknown")

    try:
        # Check scope
        api_key = getattr(request.state, "api_key", None)
        if api_key and not check_scope(api_key, "read:clause"):
            raise HTTPException(
                status_code=403, detail="Insufficient scope: read:clause required"
            )

        # Check cache first
        cache_key = get_cache_key(code, clause, "summary")
        cached_result = get_cache_entry(cache_key)
        if cached_result:
            record_request_metrics(
                "/v1/clauses/{code}/{clause}/summary",
                200,
                time.time() - t0,
                cache_hit=True,
            )
            return cached_result

        # Validate edition
        edition = get_edition_guard()

        # Generate quick summary
        ref_checksum = generate_clause_checksum(code, clause, edition)
        payload = {
            "title": f"{code} {clause}",
            "summary": f"Essential requirements for {clause} in {code} {edition}",
            "refs": {"code": code, "edition": edition, "clause": clause},
            "ref_checksum": ref_checksum,
            "telemetry": {
                "latency_ms": int((time.time() - t0) * 1000),
                "cache_hit": False,
            },
        }

        # Cache the result
        set_cache_entry(cache_key, payload.copy())

        # Record metrics
        record_request_metrics(
            "/v1/clauses/{code}/{clause}/summary",
            200,
            time.time() - t0,
            cache_hit=False,
        )

        return payload

    except HTTPException:
        raise
    except Exception as e:
        record_request_metrics(
            "/v1/clauses/{code}/{clause}/summary", 500, time.time() - t0
        )
        logger.log(
            "ERROR",
            f"Error generating summary for clause {code}:{clause}",
            request_id,
            error=str(e),
        )
        raise HTTPException(status_code=500, detail="Internal server error")


@app.post("/v1/pipeline/log")
def log(body: LogReq, request: Request, authorization: str = Header(None)):
    t0 = time.time()
    request_id = getattr(request.state, "request_id", "unknown")

    try:
        # Check scope
        api_key = getattr(request.state, "api_key", None)
        if api_key and not check_scope(api_key, "write:log"):
            raise HTTPException(
                status_code=403, detail="Insufficient scope: write:log required"
            )

        # Log to file
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "request_id": request_id,
            "artifact_id": body.artifact_id,
            "clause": body.clause,
            "edition": body.edition,
            "step": body.step,
            "actor": body.actor,
            "status": body.status,
        }

        # Ensure log directory exists
        log_dir = os.path.join(CONTENT_DIR, "pipeline")
        os.makedirs(log_dir, exist_ok=True)

        # Write to JSONL file
        log_file = os.path.join(
            log_dir, f"pipeline_{datetime.utcnow().strftime('%Y%m%d')}.jsonl"
        )
        with open(log_file, "a", encoding="utf-8") as f:
            f.write(json.dumps(log_entry) + "\n")

        # Record metrics
        record_request_metrics("/v1/pipeline/log", 200, time.time() - t0)
        logger.log(
            "INFO",
            f"Logged pipeline event",
            request_id,
            artifact_id=body.artifact_id,
            step=body.step,
            status=body.status,
        )

        return {"ok": True, "logged": True, "file": log_file}

    except HTTPException:
        raise
    except Exception as e:
        record_request_metrics("/v1/pipeline/log", 500, time.time() - t0)
        logger.log("ERROR", f"Error logging pipeline event", request_id, error=str(e))
        raise HTTPException(status_code=500, detail="Internal server error")


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=8080)

# --- KB endpoints ---
from pathlib import Path
import json
from fastapi import HTTPException

KB_DIR = Path(__file__).resolve().parents[1] / "data" / "kb"
KB_ALIASES = {"aws": "aws_ecosystem", "wit": "wit_core"}

@app.get("/v1/kb", tags=["kb"])
def kb_index():
    items = []
    if KB_DIR.exists():
        for p in KB_DIR.glob("*.json"):
            try:
                d = json.loads(p.read_text(encoding="utf-8"))
            except Exception:
                d = {}
            items.append({
                "slug": p.stem,
                "title": d.get("title", p.stem),
                "updated": d.get("updated"),
                "category": d.get("category"),
                "tags": d.get("tags", [])
            })
    return {"items": items}

@app.get("/v1/kb/{slug}", tags=["kb"])
def kb_card(slug: str):
    slug = KB_ALIASES.get(slug, slug)
    path = (KB_DIR / f"{slug}.json").resolve()
    if KB_DIR not in path.parents:
        raise HTTPException(status_code=400, detail="Invalid slug")
    if not path.exists():
        raise HTTPException(status_code=404, detail="KB card not found")
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        logger.exception("kb_read_error", extra={"slug": slug, "path": str(path)})
        raise HTTPException(status_code=500, detail="KB read error")
# --- end KB endpoints ---
